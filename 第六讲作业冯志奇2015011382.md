## 第六次作业

### 6.1	非连续内存分配的需求背景

1. 为什么要设计非连续内存分配机制？

   连续分配容易产生内碎片和外碎片，分配灵活性差，内存空间利用率低。

2. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

   段式和页式；段式大小可变，页式不可变。

3. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

   大块设计为大小可变比较灵活，好对齐，小块设计为固定大小为了方便管理。可以。

### 6.2	段式存储管理

1. 什么是段、段基址和段内偏移？

   段表示访问方式和存储数据等属性相同的一段地址空间；段基址是一个段空间的起始地址，段内偏移是数据的地址减去段基址。

2. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

   数据地址为段基址加上段内偏移。

   段反映了程序的存储逻辑结构，程序不会从一个段的基址去访问另一个段，于是不同的段可以不连续。

   好处是可以不连续，方便内存管理；麻烦是地址转换稍微复杂。

### 6.3	页式存储管理

1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

   页是访问方式和存储数据等属性相同的一段更小的逻辑地址空间，帧则是与页相同的物理地址空间，页表是存储页的信息的表，MMU是负责将逻辑地址映射为物理地址的单元，快表是存放在高速缓存中的页表的子集，高速缓存是位于CPU和主存之间的存储器，存有内存数据的子集。

2. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

   地址为页号加页内偏移。

   CPU使用连续的逻辑地址，存储访问时，逻辑地址先分成逻辑页号和页内偏移，然后通过页表的对应关系，把逻辑页面转换成物理页帧，最后再把物理页号加页内偏移得到物理地址，所以可以不连续。

   好处是，方便内存管理中的存储分配和回收；麻烦是地址转换比较复杂，并且频繁进行。

### 6.4	页表概述

1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

   页表项存有页帧号，存在位 修改位 和引用位。页帧号即逻辑页号对应的物理页号，存在位表示逻辑页号是否有对应的物理页号，修改位代表页帧号是否被修改，引用表示在过去的一段时间里页帧号是否被引用。

2. 页表大小受哪些因素影响？

   页大小，地址空间大小，进程数目

### 6.5	快表和多级页表

1. 快表（TLB）与高速缓存（cache）有什么不同？

   快表是页表的子集，并且存在于高速缓存中，高速缓存是内存数据的子集。

2. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

   快表中逻辑页号直接对应物理页号，并且之前访问过的物理页号的数据也会存到快表中。因为功耗大、成本高、并且访问多，所以造成了容量小。

3. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

   多级页表是把原来一张大的线性页表分割成若干段，每一个子页表的起始地址为上一级页表的物理页号。好处是占用内存空间小，麻烦是转化更加麻烦。

### 6.6	反置页表

1. 页寄存器机制的地址转换流程是什么？

   页寄存器机制中一个页寄存器对应一个物理帧，页寄存器中存有这个物理帧是否被占用，并且存有页号。转化流程是逻辑地址做哈希后，查找相应的页寄存器。

2. 反置页表机制的地址转换流程是什么？

   反置页表是逻辑地址加上进程号一起哈希，查找相应页寄存器。

3. 反置页表项有些什么内容？

   PID、逻辑页号、标志位。

### 6.7	段页式存储管理

1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

   把逻辑地址分为段号、页号和页内偏移，先找到对应的段号，在段内寻找到对应的页，在页号加页内偏移就是要找的地址。好处是继承了段式和页式的优点，既方便管理又提高了内存利用率，麻烦是地址转换比段式和页式都麻烦。

2. 如何实现基于段式存储管理的内存共享？

3. 如何实现基于页式存储管理的内存共享？